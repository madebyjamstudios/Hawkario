<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hawkario â€” Output</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    html, body { background: transparent; }
    .stage { position: fixed; inset: 0; display: grid; place-items: center; background: transparent; }
    .timer { font-variant-numeric: tabular-nums lining-nums; user-select: none; white-space: nowrap; }
    #fsHint { position: fixed; left: 8px; bottom: 8px; color: #999; font-size: 12px; }
  </style>
</head>
<body>
  <div class="stage"><div id="timer" class="timer">00:00</div></div>
  <div id="fsHint" class="muted">Press F for fullscreen / Esc to exit</div>
  <script>
    const timerEl = document.getElementById('timer');
    let state = {
      running: false,
      mode: 'countdown',
      durationSec: 0,
      startedAt: null,
      pausedAcc: 0,
      format: 'MM:SS',
      style: {
        fontFamily: 'Inter, Segoe UI, Roboto, Helvetica, Arial, sans-serif',
        fontWeight: '600',
        fontSizeVw: 10,
        color: '#ffffff',
        opacity: 1,
        strokeWidth: 2,
        strokeColor: '#000000',
        textShadow: '0 2px 10px rgba(0,0,0,0.5)',
        align: 'center',
        letterSpacing: 0,
        bgMode: 'transparent',
        bgColor: '#000000',
        bgOpacity: 0
      },
      warn: {
        enabled: false,
        seconds: 120,
        colorEnabled: true,
        color: '#ff3333',
        flashEnabled: false,
        flashRateMs: 500
      }
    };

    function hexToRgba(hex, opacity){
      const h = hex.replace('#','');
      const bigint = parseInt(h,16);
      const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }

    function applyStyle(style) {
      timerEl.style.fontFamily = style.fontFamily;
      timerEl.style.fontWeight = style.fontWeight;
      timerEl.style.fontSize = style.fontSizeVw + 'vw';
      timerEl.style.color = style.color;
      timerEl.style.opacity = style.opacity;
      timerEl.style.textShadow = style.textShadow;
      timerEl.style.letterSpacing = style.letterSpacing + 'em';
      timerEl.style.webkitTextStrokeWidth = (style.strokeWidth || 0) + 'px';
      timerEl.style.webkitTextStrokeColor = style.strokeColor || '#000';
      timerEl.style.textAlign = style.align || 'center';
      document.querySelector('.stage').style.placeItems = (style.align === 'left' || style.align === 'right') ? 'center start' : 'center';
      timerEl.style.justifySelf = style.align === 'left' ? 'start' : (style.align === 'right' ? 'end' : 'center');
      const bg = style.bgMode === 'solid' ? hexToRgba(style.bgColor, style.bgOpacity) : 'transparent';
      document.body.style.background = bg;
      document.querySelector('.stage').style.background = bg;
    }

    function fmt(ms) {
      const total = Math.max(0, Math.floor(ms/1000));
      const h = Math.floor(total/3600);
      const m = Math.floor((total%3600)/60);
      const s = total%60;
      const z2 = n => String(n).padStart(2, '0');
      switch(state.format){
        case 'H:MM:SS': return `${h}:${z2(m)}:${z2(s)}`;
        case 'SS': return String(total);
        default: return `${z2(m+(h*60))}:${z2(s)}`;
      }
    }

    function applyWarningState(active){
      if(active){
        if(state.warn.colorEnabled){ timerEl.style.color = state.warn.color; }
        if(state.warn.flashEnabled){
          const phase = Math.floor(Date.now()/state.warn.flashRateMs)%2;
          timerEl.style.opacity = phase ? state.style.opacity : Math.max(0.15, state.style.opacity*0.25);
        }
      } else {
        timerEl.style.color = state.style.color;
        timerEl.style.opacity = state.style.opacity;
      }
    }

    function render(){
      let elapsed;
      if(!state.running || state.startedAt === null){
        elapsed = state.mode === 'countdown' ? state.durationSec*1000 : 0;
        const remainingSecIdle = Math.floor(elapsed/1000);
        const warnActiveIdle = state.mode==='countdown' && state.warn.enabled && remainingSecIdle <= state.warn.seconds;
        applyWarningState(warnActiveIdle);
      } else {
        const now = Date.now();
        const base = now - state.startedAt + state.pausedAcc;
        if(state.mode === 'countdown'){
          elapsed = Math.max(0, (state.durationSec*1000) - base);
          if(elapsed === 0) state.running = false;
        } else {
          elapsed = base;
        }
        const remainingSec = Math.floor(elapsed/1000);
        const warnActive = state.mode==='countdown' && state.warn.enabled && remainingSec <= state.warn.seconds;
        applyWarningState(warnActive);
      }
      timerEl.textContent = fmt(elapsed);
      requestAnimationFrame(render);
    }

    // Messaging
    const channel = new BroadcastChannel('alpha-timer-channel');
    window.addEventListener('message', e => {
      if(e.data && e.data.type === 'TIMER_UPDATE') updateFromMessage(e.data.payload);
    });
    channel.onmessage = ev => {
      const msg = ev.data;
      if(msg && msg.type === 'TIMER_UPDATE') updateFromMessage(msg.payload);
    };

    function updateFromMessage(payload){
      const { command, config } = payload;
      if(config){
        state.mode = config.mode || state.mode;
        state.durationSec = config.durationSec ?? state.durationSec;
        state.format = config.format || state.format;
        if(config.style) { state.style = { ...state.style, ...config.style }; applyStyle(state.style); }
        if(config.warn){ state.warn = { ...state.warn, ...config.warn }; }
      }
      if(command === 'start'){
        state.running = true; state.startedAt = Date.now(); state.pausedAcc = 0;
      }
      if(command === 'pause'){
        if(state.running){ state.running = false; state.pausedAcc += Date.now() - state.startedAt; }
      }
      if(command === 'reset'){
        state.running = false; state.startedAt = null; state.pausedAcc = 0; applyWarningState(false);
      }
    }

    // Fullscreen shortcut
    document.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase() === 'f'){
        document.documentElement.requestFullscreen().catch(()=>{});
      }
    });

    applyStyle(state.style);
    render();
  </script>
</body>
</html>